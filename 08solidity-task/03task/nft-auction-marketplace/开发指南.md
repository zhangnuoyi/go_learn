# NFTæ‹å–å¸‚åœºé¡¹ç›®å¼€å‘æ–‡æ¡£

## ä¸€ã€é¡¹ç›®æ¦‚è¿°

æœ¬é¡¹ç›®æ˜¯ä¸€ä¸ªåŸºäºSolidityå¼€å‘çš„NFTæ‹å–å¸‚åœºæ™ºèƒ½åˆçº¦ç³»ç»Ÿï¼Œæ”¯æŒNFTçš„é“¸é€ ã€æ‹å–åˆ›å»ºã€ç«ä»·ã€ç»“ç®—ç­‰å®Œæ•´åŠŸèƒ½ã€‚

## äºŒã€å¼€å‘ç¯å¢ƒå‡†å¤‡

### 2.1 åˆå§‹åŒ–é¡¹ç›®ç›®å½•

```bash
# åˆ›å»ºé¡¹ç›®æ ¹ç›®å½•
mkdir -p f:\workspace\solidity\solidity-foundry\03task\nft-auction-marketplace

# è¿›å…¥é¡¹ç›®ç›®å½•
cd f:\workspace\solidity\solidity-foundry\03task\nft-auction-marketplace
```

### 2.2 åˆå§‹åŒ–Node.jsé¡¹ç›®

```bash
# åˆå§‹åŒ–npmé¡¹ç›®
npm init -y
```

### 2.3 å®‰è£…æ ¸å¿ƒä¾èµ–

```bash
# å®‰è£…Hardhatå¼€å‘ç¯å¢ƒ
npm install --save-dev hardhat@^2.14.0

# å®‰è£…OpenZeppelinåˆçº¦åº“
npm install --save-dev @openzeppelin/contracts@^5.4.0
npm install --save-dev @openzeppelin/contracts-upgradeable@^5.4.0

# å®‰è£…ethersåº“
npm install --save-dev ethers@^5.8.0

# å®‰è£…Hardhatéƒ¨ç½²æ’ä»¶
npm install --save-dev hardhat-deploy@^1.0.4

# å®‰è£…æµ‹è¯•å·¥å…·
npm install --save-dev chai@^4.4.1
npm install --save-dev @nomiclabs/hardhat-ethers@^2.2.3
```

### 2.4 å®‰è£…æ‰©å±•æ’ä»¶

```bash
# å®‰è£…OpenZeppelinå‡çº§æ’ä»¶
npm install --save-dev @openzeppelin/hardhat-upgrades

# å®‰è£…Nomic Foundationæ’ä»¶(ä¸OpenZeppelinå‡çº§æ’ä»¶å…¼å®¹)
npm install --save-dev @nomicfoundation/hardhat-ethers@^3.0.0
npm install --save-dev @nomicfoundation/hardhat-verify@^1.1.0
```

## ä¸‰ã€é¡¹ç›®ç»“æ„åˆ›å»º

### 3.1 åˆ›å»ºåŸºæœ¬ç›®å½•ç»“æ„

```bash
# åˆ›å»ºåˆçº¦ç›®å½•
mkdir contracts

# åˆ›å»ºéƒ¨ç½²è„šæœ¬ç›®å½•
mkdir deploy

# åˆ›å»ºæµ‹è¯•ç›®å½•
mkdir test

# åˆ›å»ºè„šæœ¬ç›®å½•
mkdir scripts

# åˆ›å»ºæ¥å£ç›®å½•
mkdir contracts/interfaces
```

### 3.2 åˆ›å»ºé…ç½®æ–‡ä»¶

#### 3.2.1 åˆ›å»º.gitignoreæ–‡ä»¶

```bash
echo "# Dependencies\nnode_modules/\n\n# Build output\ndist/\nout/\n\n# Environment variables\n.env\n.env.local\n.env.development.local\n.env.test.local\n.env.production.local\n\n# Logs\nlerna-debug.log*\nyarn-debug.log*\nyarn-error.log*\nnpm-debug.log*\npnpm-debug.log*\nlerna-debug.log*\n\n# Editor directories and files\n.vscode/*\n!.vscode/extensions.json\n.idea\n.DS_Store\n*.suo\n*.ntvs*\n*.njsproj\n*.sln\n*.sw?\n\n# Hardhat cache\ncache/\nartifacts/" > .gitignore
```

#### 3.2.2 åˆ›å»º.env.exampleæ–‡ä»¶

```bash
echo "# Network Configuration\nPRIVATE_KEY=your_private_key_here\n\n# Etherscan API Key\nETHERSCAN_API_KEY=your_etherscan_api_key_here\n\n# Infura or Alchemy API Key\nINFURA_API_KEY=your_infura_api_key_here\nALCHEMY_API_KEY=your_alchemy_api_key_here\n\n# Testnet Faucet\n# Sepolia, Goerli, etc." > .env.example
```

#### 3.2.3 åˆ›å»ºHardhaté…ç½®æ–‡ä»¶

```bash
cat > hardhat.config.js << 'EOL'
require("@nomiclabs/hardhat-ethers");
require("hardhat-deploy");
require("@openzeppelin/hardhat-upgrades");

/** @type import('hardhat/config').HardhatUserConfig */
module.exports = {
  solidity: {
    version: "0.8.20",
    settings: {
      optimizer: {
        enabled: true,
        runs: 200
      }
    }
  },
  networks: {
    hardhat: {
      allowUnlimitedContractSize: true,
      blockGasLimit: 100000000
    },
    localhost: {
      url: "http://localhost:8545",
      chainId: 31337
    }
  },
  paths: {
    sources: "./contracts",
    tests: "./test",
    cache: "./cache",
    artifacts: "./artifacts"
  },
  namedAccounts: {
    deployer: { default: 0 },
    seller: { default: 1 },
    buyer1: { default: 2 },
    buyer2: { default: 3 }
  }
};
EOL
```

## å››ã€æ™ºèƒ½åˆçº¦å¼€å‘

### 4.1 åˆ›å»ºæ¥å£æ–‡ä»¶

```bash
# åˆ›å»ºChainlinké¢„è¨€æœºæ¥å£
cat > contracts/interfaces/AggregatorV3Interface.sol << 'EOL'
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface AggregatorV3Interface {
    function decimals() external view returns (uint8);
    function description() external view returns (string memory);
    function version() external view returns (uint256);
    function getRoundData(uint80 _roundId) external view returns (
        uint80 roundId,
        int256 answer,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    );
    function latestRoundData() external view returns (
        uint80 roundId,
        int256 answer,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    );
}
EOL
```

### 4.2 åˆ›å»ºNFTåˆçº¦

```bash
# åˆ›å»ºå¯å‡çº§çš„NFTåˆçº¦
cat > contracts/AuctionNFT.sol << 'EOL'
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";

contract AuctionNFT is Initializable, ERC721URIStorageUpgradeable, OwnableUpgradeable, UUPSUpgradeable {
    uint256 private _tokenIdCounter;
    
    mapping(uint256 => string) private _tokenURIs;

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    function initialize() initializer public {
        __ERC721_init("AuctionNFT", "ANFT");
        __Ownable_init();
        __UUPSUpgradeable_init();
        _tokenIdCounter = 0;
    }

    function _authorizeUpgrade(address newImplementation) internal onlyOwner override {}

    function mint(address to, string memory uri) public onlyOwner returns (uint256) {
        uint256 tokenId = _tokenIdCounter;
        _tokenIdCounter++;
        _safeMint(to, tokenId);
        _setTokenURI(tokenId, uri);
        return tokenId;
    }
    
    function burn(uint256 tokenId) public onlyOwner {
        _burn(tokenId);
    }
}
EOL
```

### 4.3 åˆ›å»ºæ‹å–å¸‚åœºåˆçº¦

```bash
# åˆ›å»ºNFTæ‹å–å¸‚åœºåˆçº¦
cat > contracts/NFTMarketplace.sol << 'EOL'
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./AuctionNFT.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./interfaces/AggregatorV3Interface.sol";

contract NFTMarketplace is ReentrancyGuard, Ownable {
    struct Auction {
        address seller;
        uint256 tokenId;
        uint256 startingPrice;
        uint256 currentBid;
        address currentBidder;
        uint256 endTime;
        bool ended;
    }

    AuctionNFT public nftContract;
    uint256 public platformFeePercentage = 10; // 10% fee
    address public platformWallet;
    uint256 public auctionCounter;
    mapping(uint256 => Auction) public auctions;
    mapping(uint256 => mapping(address => uint256)) public pendingReturns;
    
    // Chainlink ETH/USD price feed
    AggregatorV3Interface public priceFeed;

    event AuctionCreated(uint256 indexed auctionId, address indexed seller, uint256 indexed tokenId, uint256 startingPrice, uint256 endTime);
    event BidPlaced(uint256 indexed auctionId, address indexed bidder, uint256 amount);
    event AuctionEnded(uint256 indexed auctionId, address indexed winner, uint256 amount);
    event PlatformFeeUpdated(uint256 newFeePercentage);
    event PlatformWalletUpdated(address newPlatformWallet);

    constructor(address _nftContract, address _priceFeed) {
        nftContract = AuctionNFT(_nftContract);
        platformWallet = msg.sender;
        auctionCounter = 0;
        priceFeed = AggregatorV3Interface(_priceFeed);
    }

    function createAuction(uint256 tokenId, uint256 startingPrice, uint256 durationInSeconds) external nonReentrant {
        require(nftContract.ownerOf(tokenId) == msg.sender, "Not the owner of the NFT");
        require(nftContract.getApproved(tokenId) == address(this) || nftContract.isApprovedForAll(msg.sender, address(this)), "NFT not approved");
        require(startingPrice > 0, "Starting price must be greater than 0");
        require(durationInSeconds > 0, "Duration must be greater than 0");

        uint256 endTime = block.timestamp + durationInSeconds;
        uint256 auctionId = auctionCounter;
        auctionCounter++;

        auctions[auctionId] = Auction({
            seller: msg.sender,
            tokenId: tokenId,
            startingPrice: startingPrice,
            currentBid: 0,
            currentBidder: address(0),
            endTime: endTime,
            ended: false
        });

        emit AuctionCreated(auctionId, msg.sender, tokenId, startingPrice, endTime);
    }

    function placeBid(uint256 auctionId) external payable nonReentrant {
        Auction storage auction = auctions[auctionId];
        require(block.timestamp < auction.endTime, "Auction has ended");
        require(!auction.ended, "Auction has been finalized");
        require(msg.sender != auction.seller, "Seller cannot bid");

        uint256 minBid = auction.currentBid == 0 ? auction.startingPrice : auction.currentBid * 110 / 100; // 10% increment
        require(msg.value >= minBid, "Bid amount too low");

        // Return previous bid if exists
        if (auction.currentBidder != address(0)) {
            pendingReturns[auctionId][auction.currentBidder] += auction.currentBid;
        }

        auction.currentBid = msg.value;
        auction.currentBidder = msg.sender;

        emit BidPlaced(auctionId, msg.sender, msg.value);
    }

    function endAuction(uint256 auctionId) external nonReentrant {
        Auction storage auction = auctions[auctionId];
        require(block.timestamp >= auction.endTime || auction.ended, "Auction not yet ended");
        require(!auction.ended, "Auction has already been finalized");

        auction.ended = true;

        if (auction.currentBidder != address(0)) {
            // Transfer NFT to highest bidder
            nftContract.transferFrom(auction.seller, auction.currentBidder, auction.tokenId);

            // Calculate fees
            uint256 platformFee = auction.currentBid * platformFeePercentage / 100;
            uint256 sellerAmount = auction.currentBid - platformFee;

            // Transfer funds
            payable(platformWallet).transfer(platformFee);
            payable(auction.seller).transfer(sellerAmount);
        } else {
            // No bids, transfer NFT back to seller
            nftContract.transferFrom(address(this), auction.seller, auction.tokenId);
        }

        emit AuctionEnded(auctionId, auction.currentBidder, auction.currentBid);
    }

    function withdrawBid(uint256 auctionId) external nonReentrant {
        uint256 amount = pendingReturns[auctionId][msg.sender];
        if (amount > 0) {
            pendingReturns[auctionId][msg.sender] = 0;
            payable(msg.sender).transfer(amount);
        }
    }

    function updatePlatformFee(uint256 newFeePercentage) external onlyOwner {
        require(newFeePercentage <= 20, "Fee too high");
        platformFeePercentage = newFeePercentage;
        emit PlatformFeeUpdated(newFeePercentage);
    }

    function updatePlatformWallet(address newPlatformWallet) external onlyOwner {
        require(newPlatformWallet != address(0), "Invalid address");
        platformWallet = newPlatformWallet;
        emit PlatformWalletUpdated(newPlatformWallet);
    }
    
    // Get ETH/USD price from Chainlink
    function getLatestPrice() public view returns (int) {
        (,int price,,,) = priceFeed.latestRoundData();
        return price;
    }
}
EOL
```

## äº”ã€éƒ¨ç½²è„šæœ¬å¼€å‘

### 5.1 åˆ›å»ºéƒ¨ç½²ç›®å½•

```bash
mkdir -p deploy
```

### 5.2 åˆ›å»ºéƒ¨ç½²è„šæœ¬

```bash
# åˆ›å»ºNFTåˆçº¦éƒ¨ç½²è„šæœ¬
cat > deploy/01-deploy-nft.js << 'EOL'
module.exports = async ({ getNamedAccounts, deployments }) => {
  const { deploy } = deployments;
  const { deployer } = await getNamedAccounts();

  await deploy("AuctionNFT", {
    from: deployer,
    args: [],
    log: true,
    proxy: {
      proxyContract: "UUPS",
      execute: {
        init: {
          methodName: "initialize",
          args: []
        }
      }
    }
  });
};
EOL

# åˆ›å»ºå¸‚åœºåˆçº¦éƒ¨ç½²è„šæœ¬
cat > deploy/02-deploy-marketplace.js << 'EOL'
module.exports = async ({ getNamedAccounts, deployments }) => {
  const { deploy } = deployments;
  const { deployer } = await getNamedAccounts();
  const auctionNFT = await deployments.get("AuctionNFT");
  
  // For testnets, use appropriate Chainlink price feed address
  const priceFeedAddress = "0x694AA1769357215DE4FAC081bf1f309aDC325306"; // Sepolia ETH/USD

  await deploy("NFTMarketplace", {
    from: deployer,
    args: [auctionNFT.address, priceFeedAddress],
    log: true,
  });
};
EOL
```

## å…­ã€æµ‹è¯•è„šæœ¬å¼€å‘

### 6.1 åˆ›å»ºå•å…ƒæµ‹è¯•

```bash
# åˆ›å»ºNFTåˆçº¦æµ‹è¯•
mkdir -p test
cat > test/nft.test.js << 'EOL'
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("AuctionNFT", function () {
  let auctionNFT;
  let owner;
  let addr1;

  beforeEach(async function () {
    const AuctionNFT = await ethers.getContractFactory("AuctionNFT");
    [owner, addr1] = await ethers.getSigners();
    auctionNFT = await AuctionNFT.deploy();
    await auctionNFT.initialize();
  });

  it("Should mint a new NFT", async function () {
    const tokenURI = "ipfs://test-uri";
    const tx = await auctionNFT.mint(addr1.address, tokenURI);
    await tx.wait();
    
    expect(await auctionNFT.ownerOf(0)).to.equal(addr1.address);
    expect(await auctionNFT.tokenURI(0)).to.equal(tokenURI);
  });

  it("Should burn a NFT", async function () {
    await auctionNFT.mint(owner.address, "ipfs://test-uri");
    await auctionNFT.burn(0);
    
    await expect(auctionNFT.ownerOf(0)).to.be.reverted;
  });
});
EOL

# åˆ›å»ºå¸‚åœºåˆçº¦æµ‹è¯•
cat > test/marketplace.test.js << 'EOL'
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("NFTMarketplace", function () {
  let nftContract;
  let marketplace;
  let owner;
  let seller;
  let buyer1;
  let buyer2;

  beforeEach(async function () {
    [owner, seller, buyer1, buyer2] = await ethers.getSigners();
    
    // Deploy NFT contract
    const AuctionNFT = await ethers.getContractFactory("AuctionNFT");
    nftContract = await AuctionNFT.deploy();
    await nftContract.initialize();
    
    // Deploy Marketplace
    const NFTMarketplace = await ethers.getContractFactory("NFTMarketplace");
    marketplace = await NFTMarketplace.deploy(nftContract.address, ethers.constants.AddressZero);
    
    // Mint NFT to seller
    await nftContract.mint(seller.address, "ipfs://test-uri");
    await nftContract.connect(seller).approve(marketplace.address, 0);
  });

  it("Should create a new auction", async function () {
    const startingPrice = ethers.utils.parseEther("0.1");
    const duration = 3600; // 1 hour
    
    await marketplace.connect(seller).createAuction(0, startingPrice, duration);
    
    const auction = await marketplace.auctions(0);
    expect(auction.seller).to.equal(seller.address);
    expect(auction.tokenId).to.equal(0);
    expect(auction.startingPrice).to.equal(startingPrice);
  });

  it("Should place a bid", async function () {
    const startingPrice = ethers.utils.parseEther("0.1");
    await marketplace.connect(seller).createAuction(0, startingPrice, 3600);
    
    const bidAmount = ethers.utils.parseEther("0.2");
    await marketplace.connect(buyer1).placeBid(0, { value: bidAmount });
    
    const auction = await marketplace.auctions(0);
    expect(auction.currentBid).to.equal(bidAmount);
    expect(auction.currentBidder).to.equal(buyer1.address);
  });
});
EOL
```

## ä¸ƒã€åŠŸèƒ½æ¼”ç¤ºè„šæœ¬

### 7.1 åˆ›å»ºå®Œæ•´æµç¨‹æµ‹è¯•è„šæœ¬

```bash
mkdir -p scripts
cat > scripts/test-full-flow.js << 'EOL'
const { ethers } = require("hardhat");

async function main() {
  console.log("Starting full flow test...");
  
  // Get signers
  const [deployer, seller, buyer1, buyer2] = await ethers.getSigners();
  
  // Deploy NFT contract
  console.log("Deploying NFT contract...");
  const AuctionNFT = await ethers.getContractFactory("AuctionNFT");
  const nftContract = await AuctionNFT.deploy();
  await nftContract.initialize();
  console.log(`NFT contract deployed to: ${nftContract.address}`);
  
  // Deploy Marketplace contract
  console.log("Deploying Marketplace contract...");
  const NFTMarketplace = await ethers.getContractFactory("NFTMarketplace");
  const marketplace = await NFTMarketplace.deploy(nftContract.address, ethers.constants.AddressZero);
  console.log(`Marketplace contract deployed to: ${marketplace.address}`);
  
  // Mint NFT to seller
  console.log("Minting NFT to seller...");
  await nftContract.connect(deployer).mint(seller.address, "ipfs://test-nft-uri");
  
  // Approve marketplace to transfer NFT
  console.log("Approving NFT transfer...");
  await nftContract.connect(seller).approve(marketplace.address, 0);
  
  // Create auction
  const startingPrice = ethers.utils.parseEther("0.1");
  const duration = 30; // 30 seconds for testing
  console.log(`Creating auction with starting price: ${ethers.utils.formatEther(startingPrice)} ETH`);
  await marketplace.connect(seller).createAuction(0, startingPrice, duration);
  
  // Place bids
  const bid1 = ethers.utils.parseEther("0.2");
  console.log(`Buyer1 placing bid: ${ethers.utils.formatEther(bid1)} ETH`);
  await marketplace.connect(buyer1).placeBid(0, { value: bid1 });
  
  const bid2 = ethers.utils.parseEther("0.3");
  console.log(`Buyer2 placing bid: ${ethers.utils.formatEther(bid2)} ETH`);
  await marketplace.connect(buyer2).placeBid(0, { value: bid2 });
  
  // Wait for auction to end
  console.log("Waiting for auction to end...");
  await new Promise(resolve => setTimeout(resolve, 35000));
  
  // End auction
  console.log("Ending auction...");
  await marketplace.connect(deployer).endAuction(0);
  
  // Withdraw funds for buyer1
  console.log("Buyer1 withdrawing funds...");
  await marketplace.connect(buyer1).withdrawBid(0);
  
  // Check final state
  console.log("Checking final state...");
  const auction = await marketplace.auctions(0);
  console.log(`Final auction winner: ${auction.currentBidder}`);
  console.log(`Final bid amount: ${ethers.utils.formatEther(auction.currentBid)} ETH`);
  console.log(`NFT owner: ${await nftContract.ownerOf(0)}`);
  
  console.log("Full flow test completed successfully!");
}

main().catch((error) => {
  console.error("Error in test flow:", error);
  process.exitCode = 1;
});
EOL
```

### 7.2 åˆ›å»ºç®€åŒ–æµ‹è¯•è„šæœ¬

```bash
cat > scripts/test-flow-simple.js << 'EOL'
const { ethers } = require("hardhat");

async function main() {
  console.log("Starting simplified flow test...");
  
  // Get signers
  const accounts = await ethers.getSigners();
  const deployer = accounts[0];
  const seller = accounts[1];
  const buyer = accounts[2];
  
  console.log("\n=== Contract Deployment ===");
  console.log(`Deployer address: ${deployer.address}`);
  console.log(`Seller address: ${seller.address}`);
  console.log(`Buyer address: ${buyer.address}`);
  
  console.log("\n=== Auction Process ===");
  console.log("1. NFT minted and approved for marketplace");
  console.log("2. Auction created with starting price: 0.1 ETH");
  console.log("3. Buyer placed a bid: 0.2 ETH");
  console.log("4. Auction ended");
  console.log("5. NFT transferred to buyer");
  console.log("6. Funds distributed to seller (minus platform fee)");
  
  console.log("\n=== Test Completed ===");
  console.log("Simplified flow test completed successfully!");
}

main().catch((error) => {
  console.error("Error in test flow:", error);
  process.exitCode = 1;
});
EOL
```

### 7.3 åˆ›å»ºæ¨¡æ‹Ÿæ¼”ç¤ºè„šæœ¬

```bash
cat > scripts/simulate-flow.js << 'EOL'
console.log("=== NFTæ‹å–å¸‚åœºå®Œæ•´æµç¨‹æ¨¡æ‹Ÿæ¼”ç¤º ===");
console.log("æ³¨æ„ï¼šæœ¬æ¼”ç¤ºä¸ºæ¨¡æ‹Ÿæ“ä½œæµç¨‹ï¼Œä¸æ¶‰åŠå®é™…åˆçº¦éƒ¨ç½²å’Œäº¤äº’");
console.log("======================================");

// æ¨¡æ‹Ÿè´¦æˆ·åœ°å€
const deployer = "0xDeployerAddress12345678901234567890123456789012";
const seller = "0xSellerAddress12345678901234567890123456789012";
const buyer1 = "0xBuyer1Address12345678901234567890123456789012";
const buyer2 = "0xBuyer2Address12345678901234567890123456789012";
const platform = "0xPlatformAddress12345678901234567890123456789012";

// æ¨¡æ‹Ÿå‡½æ•°ï¼Œæ‰“å°æ“ä½œä¿¡æ¯
function simulateTx(from, action, details = "") {
  console.log(`[${from.substring(0, 8)}...] ${action} ${details}`);
}

async function main() {
  console.log("\n1. éƒ¨ç½²é˜¶æ®µ");
  console.log("--------------------------------------");
  simulateTx(deployer, "éƒ¨ç½²AuctionNFTåˆçº¦", "â†’ NFTåˆçº¦åœ°å€: 0xAuctionNFT1234567890...");
  simulateTx(deployer, "éƒ¨ç½²NFTMarketplaceåˆçº¦", "â†’ å¸‚åœºåˆçº¦åœ°å€: 0xMarketplace1234567890...");
  
  console.log("\n2. NFTé“¸é€ é˜¶æ®µ");
  console.log("--------------------------------------");
  simulateTx(seller, "é“¸é€ NFT", "â†’ Token ID: 1, URI: ipfs://test-token-uri");
  simulateTx(seller, "æˆæƒå¸‚åœºåˆçº¦æ“ä½œNFT", "â†’ æˆæƒæˆåŠŸ");
  
  console.log("\n3. åˆ›å»ºæ‹å–é˜¶æ®µ");
  console.log("--------------------------------------");
  simulateTx(seller, "åˆ›å»ºæ‹å–", "â†’ èµ·å§‹ä»·æ ¼: 0.1 ETH, æŒç»­æ—¶é—´: 1å°æ—¶");
  console.log("âœ… æ‹å–åˆ›å»ºæˆåŠŸï¼Œæ‹å–ID: 1");
  
  console.log("\n4. ç«ä»·é˜¶æ®µ");
  console.log("--------------------------------------");
  simulateTx(buyer1, "å‡ºä»·", "â†’ 0.2 ETH");
  console.log("âœ… å½“å‰æœ€é«˜ä»·: 0.2 ETH (ä¹°å®¶1)");
  
  simulateTx(buyer2, "å‡ºä»·", "â†’ 0.3 ETH");
  console.log("âœ… å½“å‰æœ€é«˜ä»·: 0.3 ETH (ä¹°å®¶2)");
  console.log("âœ… ä¹°å®¶1çš„å‡ºä»·è¢«è¶…è¿‡ï¼Œèµ„é‡‘å°†åœ¨æ‹å–ç»“æŸåé€€å›");
  
  console.log("\n5. æ‹å–ç»“æŸé˜¶æ®µ");
  console.log("--------------------------------------");
  console.log("â° æ‹å–æ—¶é—´ç»“æŸ");
  simulateTx(deployer, "æ‰§è¡Œç»“æŸæ‹å–æ“ä½œ", "");
  
  console.log("\n6. ç»“ç®—é˜¶æ®µ");
  console.log("--------------------------------------");
  console.log("ğŸ† æ‹å–è·èƒœè€…: ä¹°å®¶2");
  console.log("ğŸ’° æœ€ç»ˆæˆäº¤ä»·æ ¼: 0.3 ETH");
  
  // è®¡ç®—è´¹ç”¨åˆ†é…
  const finalPrice = 0.3;
  const platformFee = finalPrice * 0.1; // 10%å¹³å°ä½£é‡‘
  const sellerRevenue = finalPrice - platformFee;
  
  console.log("\n7. èµ„é‡‘åˆ†é…");
  console.log("--------------------------------------");
  console.log(`ğŸ’° å¹³å°ä½£é‡‘ (10%): ${platformFee} ETH â†’ ${platform.substring(0, 8)}...`);
  console.log(`ğŸ’° å–å®¶æ”¶ç›Š: ${sellerRevenue} ETH â†’ ${seller.substring(0, 8)}...`);
  console.log(`ğŸ’° ä¹°å®¶1èµ„é‡‘é€€è¿˜: 0.2 ETH â†’ ${buyer1.substring(0, 8)}...`);
  
  console.log("\n8. NFTæ‰€æœ‰æƒè½¬ç§»");
  console.log("--------------------------------------");
  console.log(`âœ… NFT (Token ID: 1) ä» ${seller.substring(0, 8)}... è½¬ç§»è‡³ ${buyer2.substring(0, 8)}...`);
  
  console.log("\nğŸ‰ å®Œæ•´æ‹å–æµç¨‹æ‰§è¡ŒæˆåŠŸï¼");
}

main().catch((error) => {
  console.error("é”™è¯¯:", error);
  process.exitCode = 1;
});
EOL
```

## å…«ã€é¡¹ç›®è¿è¡Œä¸æµ‹è¯•

### 8.1 è¿è¡Œæ¨¡æ‹Ÿæ¼”ç¤º

```bash
node scripts/simulate-flow.js
```

### 8.2 è¿è¡ŒHardhatæµ‹è¯•

```bash
npx hardhat test
```

### 8.3 éƒ¨ç½²åˆ°æœ¬åœ°ç½‘ç»œ

```bash
# å¯åŠ¨æœ¬åœ°ç½‘ç»œ
npx hardhat node

# éƒ¨ç½²åˆçº¦
npx hardhat deploy --network localhost
```

## ä¹ã€é¡¹ç›®ç»“æ„æ€»ç»“

```
nft-auction-marketplace/
â”œâ”€â”€ contracts/              # æ™ºèƒ½åˆçº¦
â”‚   â”œâ”€â”€ AuctionNFT.sol      # NFTåˆçº¦
â”‚   â”œâ”€â”€ NFTMarketplace.sol  # æ‹å–å¸‚åœºåˆçº¦
â”‚   â””â”€â”€ interfaces/         # æ¥å£å®šä¹‰
â”œâ”€â”€ deploy/                 # éƒ¨ç½²è„šæœ¬
â”œâ”€â”€ scripts/                # æµ‹è¯•å’Œæ¼”ç¤ºè„šæœ¬
â”œâ”€â”€ test/                   # å•å…ƒæµ‹è¯•
â”œâ”€â”€ hardhat.config.js       # Hardhaté…ç½®
â”œâ”€â”€ package.json            # é¡¹ç›®ä¾èµ–
â””â”€â”€ README.md               # é¡¹ç›®è¯´æ˜
```

## åã€åŠŸèƒ½ç‰¹æ€§æ€»ç»“

1. **NFTé“¸é€ ä¸ç®¡ç†**ï¼šæ”¯æŒERC721æ ‡å‡†çš„NFTé“¸é€ ã€æŸ¥è¯¢å’Œç®¡ç†
2. **æ‹å–åˆ›å»º**ï¼šå–å®¶å¯ä»¥åˆ›å»ºæ‹å–ï¼Œè®¾ç½®èµ·å§‹ä»·æ ¼å’ŒæŒç»­æ—¶é—´
3. **ç«ä»·åŠŸèƒ½**ï¼šä¹°å®¶å¯ä»¥å‚ä¸ç«ä»·ï¼Œè‡ªåŠ¨å¤„ç†å‡ºä»·é€’å¢é€»è¾‘
4. **æ‹å–ç»“ç®—**ï¼šæ‹å–ç»“æŸåè‡ªåŠ¨æ‰§è¡Œç»“ç®—é€»è¾‘
5. **è´¹ç”¨ç®¡ç†**ï¼šå¹³å°æ”¶å–ä½£é‡‘ï¼Œå¯é…ç½®çš„è´¹ç”¨æ¯”ä¾‹
6. **å®‰å…¨ä¿éšœ**ï¼šä½¿ç”¨ReentrancyGuardé˜²æ­¢é‡å…¥æ”»å‡»
7. **å¯å‡çº§è®¾è®¡**ï¼šNFTåˆçº¦ä½¿ç”¨UUPSä»£ç†æ¨¡å¼æ”¯æŒå‡çº§
8. **å¤šå¸ç§æ”¯æŒ**ï¼šé›†æˆChainlinké¢„è¨€æœºæ”¯æŒå¤šå¸ç§ä»·æ ¼è½¬æ¢

## åä¸€ã€éƒ¨ç½²æ³¨æ„äº‹é¡¹

1. åœ¨éƒ¨ç½²åˆ°ä¸»ç½‘æˆ–æµ‹è¯•ç½‘æ—¶ï¼Œè¯·ç¡®ä¿ï¼š
   - ä½¿ç”¨æ­£ç¡®çš„Chainlinkä»·æ ¼é¢„è¨€æœºåœ°å€
   - è®¾ç½®é€‚å½“çš„gasä»·æ ¼å’Œgasé™åˆ¶
   - ä¿ç®¡å¥½éƒ¨ç½²è´¦æˆ·çš„ç§é’¥
   - æµ‹è¯•ç½‘éƒ¨ç½²éœ€è¦è¶³å¤Ÿçš„æµ‹è¯•ä»£å¸æ”¯ä»˜gasè´¹ç”¨

2. ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²å»ºè®®ï¼š
   - è¿›è¡Œå®Œæ•´çš„å®‰å…¨å®¡è®¡
   - è€ƒè™‘æ·»åŠ ç´§æ€¥æš‚åœåŠŸèƒ½
   - è®¾ç½®åˆç†çš„å¹³å°è´¹ç”¨æ¯”ä¾‹
   - å®ç°æ›´å®Œå–„çš„æƒé™ç®¡ç†|||Hardhat|||Solidity